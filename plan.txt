
1. Drivetrain and manipulator nodes publish to:

    /manipulator/shoulder/speed_cmd
    /manipulator/shoulder/reset_cmd
    /drivetrain/front_left/speed_cmd
    etc.

2. Motor node parsing:

    put in arbitration id, uart port

    listens to topic namespace (shown above), recieves can message parameters
    creates can message
    sends server request to can or uart nodes

3. Hardware node executes:

    recieves service requests to send uart/can
    sends uart/can data over interfaces
    replies with uart/can back to motor nodes

4. Motor node parses:

    motor node gets service response, runs through parse messages in library
    publishes out values to topics

    /manipulator/shoulder/speed_response_data


Above plan:
-----------
                                              service response
                          (motor library)          <---
Control nodes    ---->      Motor nodes            --->          Hardware nodes (can/uart) 
                publish          |            service request
                                 |
                                 |
                                 | publish motor data everywhere
                                 |
                                 V

Pros:
    - can access all motor commands through ros
    - motor library is never touched by programmer working on control node
    - only data floating around in ros is motor response data
    - maximally necessary abstraction 
        - control nodes do not know what communication protol is used

Cons:
    - Not sure if delay will be significant for doing a feedback controller
    - need to make service type for each motor command
    - 


Alternatives:

    - make one huge message for every value we can get back from motor
    
        Pros:
            - easy format
        Cons:
            - need to add flags for each field indicating if it is used
                - (ints and floats default to zero in msgs)
            - wasted message space in publishing over network